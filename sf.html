<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>MIDI Player with SoundFont (.sf2)</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 20px; background:black; color:white;}
  .log { white-space: pre-wrap; font-family: ui-monospace, monospace; background: #111; color: #ddd; padding: 10px; border-radius: 6px; max-height: 200px; overflow-y: auto; }
  button { margin-right: 8px; padding: 8px 16px; }
  .file-input { margin: 10px 0; }
  .status { color: #4a4; margin: 10px 0; }
</style>
</head>
<body>
  <h1>MIDI Player with SoundFont (.sf2)</h1>
  
  <div class="file-input">
    <label>SoundFont (.sf2): </label>
    <input type="file" id="sf2File" accept=".sf2" />
    <span id="sf2Status" class="status"></span>
  </div>
  
  <div class="file-input">
    <label>MIDI File (.mid): </label>
    <input type="file" id="midiFile" accept=".mid,.midi" />
  </div>
  
  <button id="playBtn" disabled>Play</button>
  <button id="stopBtn" disabled>Stop</button>
  
  <div id="visualizer" style="display:grid; grid-template-columns:repeat(4,1fr); gap:0px; margin:20px 0;">
  </div>
  
  <div class="log" id="log"></div>

<script>
// ============ SoundFont Parser ============
class SoundFontParser {
  constructor(arrayBuffer) {
    this.data = new DataView(arrayBuffer);
    this.offset = 0;
    this.presets = [];
    this.presetBags = [];
    this.presetGens = [];
    this.instruments = [];
    this.instrumentBags = [];
    this.instrumentGens = [];
    this.samples = [];
    this.sampleData = null;
  }

  checkBounds(bytes) {
    if (this.offset + bytes > this.data.byteLength) {
      throw new Error(`Read beyond file bounds: offset=${this.offset}, need=${bytes}, size=${this.data.byteLength}`);
    }
  }

  readString(len) {
    this.checkBounds(len);
    let str = '';
    for (let i = 0; i < len; i++) {
      const c = this.data.getUint8(this.offset++);
      if (c !== 0) str += String.fromCharCode(c);
    }
    return str;
  }

  readUint32() {
    this.checkBounds(4);
    const v = this.data.getUint32(this.offset, true);
    this.offset += 4;
    return v;
  }

  readUint16() {
    this.checkBounds(2);
    const v = this.data.getUint16(this.offset, true);
    this.offset += 2;
    return v;
  }

  readInt16() {
    this.checkBounds(2);
    const v = this.data.getInt16(this.offset, true);
    this.offset += 2;
    return v;
  }

  readUint8() {
    this.checkBounds(1);
    return this.data.getUint8(this.offset++);
  }

  findChunk(id, startOffset = 0) {
    this.offset = startOffset;
    while (this.offset < this.data.byteLength - 8) {
      const chunkId = this.readString(4);
      const size = this.readUint32();
      if (chunkId === id) {
        return { offset: this.offset, size };
      }
      this.offset += size;
    }
    return null;
  }

  findSubChunk(parentOffset, parentSize, id) {
    const endOffset = parentOffset + parentSize;
    this.offset = parentOffset;
    
    while (this.offset < endOffset - 8 && this.offset + 8 <= this.data.byteLength) {
      try {
        const chunkId = this.readString(4);
        const size = this.readUint32();
        if (chunkId === id) {
          return { offset: this.offset, size };
        }
        this.offset += size;
      } catch (e) {
        console.warn('Error reading sub-chunk:', e.message);
        break;
      }
    }
    return null;
  }

  parse() {
    try {
      // RIFFヘッダー確認
      const riff = this.readString(4);
      if (riff !== 'RIFF') throw new Error('Not a valid RIFF file');
      
      const fileSize = this.readUint32();
      const sfbk = this.readString(4);
      if (sfbk !== 'sfbk') throw new Error('Not a SoundFont file');

      console.log('SF2 file detected, size:', fileSize);

      // LISTチャンクを探す
      this.offset = 12; // RIFF header後
      
      while (this.offset < this.data.byteLength - 8 && this.offset + 8 <= this.data.byteLength) {
        try {
          const chunkId = this.readString(4);
          const chunkSize = this.readUint32();
          const chunkDataStart = this.offset;
          
          console.log(`Found chunk: ${chunkId}, size: ${chunkSize}, offset: ${chunkDataStart}`);
          
          // チャンクサイズの妥当性チェック
          if (chunkSize > this.data.byteLength - chunkDataStart + 8) {
            console.warn(`Invalid chunk size: ${chunkSize}, skipping`);
            break;
          }
          
          if (chunkId === 'LIST' && chunkSize >= 4) {
            const listType = this.readString(4);
            console.log(`  LIST type: ${listType}`);
            
            if (listType === 'sdta') {
              // サンプルデータ
              const smplChunk = this.findSubChunk(this.offset, chunkSize - 4, 'smpl');
              if (smplChunk && smplChunk.offset + smplChunk.size <= this.data.byteLength) {
                this.offset = smplChunk.offset;
                const start = this.offset;
                const sampleCount = Math.floor(smplChunk.size / 2);
                this.sampleData = new Int16Array(this.data.buffer, start, sampleCount);
                console.log('Sample data loaded:', smplChunk.size, 'bytes,', sampleCount, 'samples');
              }
            } else if (listType === 'pdta') {
              // プリセット/インストゥルメントデータ
              console.log('Processing pdta chunk...');
              this.parsePdta(this.offset, chunkSize - 4);
            }
          }
          
          this.offset = chunkDataStart + chunkSize;
          
          // アライメント調整（ワード境界）
          if (chunkSize % 2 === 1) {
            this.offset++;
          }
        } catch (e) {
          console.warn('Error processing chunk:', e.message);
          break;
        }
      }

      if (this.presets.length === 0) {
        console.warn('No presets found');
      }
      
      if (this.samples.length === 0) {
        console.warn('No samples found');
      }

      return {
        presets: this.presets,
        presetBags: this.presetBags,
        presetGens: this.presetGens,
        instruments: this.instruments,
        instrumentBags: this.instrumentBags,
        instrumentGens: this.instrumentGens,
        samples: this.samples,
        sampleData: this.sampleData
      };
    } catch (e) {
      console.error('Parse error:', e.message, 'at offset:', this.offset);
      throw e;
    }
  }

  parsePdta(startOffset, size) {
    const endOffset = Math.min(startOffset + size, this.data.byteLength);
    this.offset = startOffset;
    
    while (this.offset < endOffset - 8 && this.offset + 8 <= this.data.byteLength) {
      try {
        const subId = this.readString(4);
        const subSize = this.readUint32();
        const subStart = this.offset;
        
        console.log(`  pdta sub-chunk: ${subId}, size: ${subSize}, offset: ${subStart}`);
        
        if (subSize > this.data.byteLength - subStart + 8 || subSize < 0) {
          console.warn(`Invalid sub-chunk size: ${subSize}, skipping rest of pdta`);
          break;
        }

        if (subId === 'phdr' && subSize >= 38) {
          this.parsePresetHeaders(subSize);
        } else if (subId === 'pbag' && subSize >= 4) {
          this.parsePresetBags(subSize);
        } else if (subId === 'pgen' && subSize >= 4) {
          this.parsePresetGens(subSize);
        } else if (subId === 'inst' && subSize >= 22) {
          this.parseInstruments(subSize);
        } else if (subId === 'ibag' && subSize >= 4) {
          this.parseInstrumentBags(subSize);
        } else if (subId === 'igen' && subSize >= 4) {
          this.parseInstrumentGens(subSize);
        } else if (subId === 'shdr' && subSize >= 46) {
          this.parseSampleHeaders(subSize);
        }

        this.offset = subStart + subSize;
        
        if (subSize % 2 === 1) {
          this.offset++;
        }
      } catch (e) {
        console.warn('Error parsing pdta sub-chunk:', e.message);
        break;
      }
    }
  }

  parsePresetBags(size) {
    const count = Math.floor(size / 4);
    console.log(`  Parsing ${count} preset bags`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 4 > this.data.byteLength) break;
        const genNdx = this.readUint16();
        const modNdx = this.readUint16();
        this.presetBags.push({ genNdx, modNdx });
      }
    } catch (e) {
      console.warn('Error parsing preset bags:', e.message);
    }
  }

  parsePresetGens(size) {
    const count = Math.floor(size / 4);
    console.log(`  Parsing ${count} preset generators`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 4 > this.data.byteLength) break;
        const oper = this.readUint16();
        const amount = this.readUint16();
        this.presetGens.push({ oper, amount });
      }
    } catch (e) {
      console.warn('Error parsing preset gens:', e.message);
    }
  }

  parseInstrumentBags(size) {
    const count = Math.floor(size / 4);
    console.log(`  Parsing ${count} instrument bags`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 4 > this.data.byteLength) break;
        const genNdx = this.readUint16();
        const modNdx = this.readUint16();
        this.instrumentBags.push({ genNdx, modNdx });
      }
    } catch (e) {
      console.warn('Error parsing instrument bags:', e.message);
    }
  }

  parseInstrumentGens(size) {
    const count = Math.floor(size / 4);
    console.log(`  Parsing ${count} instrument generators`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 4 > this.data.byteLength) break;
        const oper = this.readUint16();
        const amount = this.readUint16();
        this.instrumentGens.push({ oper, amount });
      }
    } catch (e) {
      console.warn('Error parsing instrument gens:', e.message);
    }
  }

  parsePresetHeaders(size) {
    const count = Math.floor(size / 38);
    console.log(`  Parsing ${count} preset headers`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 38 > this.data.byteLength) {
          console.warn('Reached end of file while parsing presets');
          break;
        }
        
        const name = this.readString(20);
        const preset = this.readUint16();
        const bank = this.readUint16();
        const presetBagNdx = this.readUint16();
        const library = this.readUint32();
        const genre = this.readUint32();
        const morphology = this.readUint32();
        
        // 終端プリセットをスキップ
        if (i < count - 1) {
          this.presets.push({ name, preset, bank, presetBagNdx });
          if (i < 5) console.log(`    Preset: ${name} (${bank}:${preset})`);
        }
      }
    } catch (e) {
      console.warn('Error parsing preset headers:', e.message);
    }
  }

  parseInstruments(size) {
    const count = Math.floor(size / 22);
    console.log(`  Parsing ${count} instruments`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 22 > this.data.byteLength) {
          console.warn('Reached end of file while parsing instruments');
          break;
        }
        
        const name = this.readString(20);
        const instBagNdx = this.readUint16();
        
        // 終端インストゥルメントをスキップ
        if (i < count - 1) {
          this.instruments.push({ name, instBagNdx });
          if (i < 5) console.log(`    Instrument: ${name}`);
        }
      }
    } catch (e) {
      console.warn('Error parsing instruments:', e.message);
    }
  }

  parseSampleHeaders(size) {
    const count = Math.floor(size / 46);
    console.log(`  Parsing ${count} sample headers (${size} bytes total)`);
    
    const startingOffset = this.offset;
    const tempSamples = [];
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 46 > this.data.byteLength) {
          console.warn(`Reached end of file while parsing samples (${i}/${count})`);
          break;
        }
        
        const sampleOffset = this.offset;
        
        // SF2仕様: 20バイト名前、各4バイト×5、4バイト、1バイト、1バイト、2バイト、2バイト = 46バイト
        const name = this.readString(20);      // 20 bytes
        const start = this.readUint32();        // 4 bytes
        const end = this.readUint32();          // 4 bytes  
        const startLoop = this.readUint32();    // 4 bytes
        const endLoop = this.readUint32();      // 4 bytes
        const sampleRate = this.readUint32();   // 4 bytes
        const originalPitch = this.readUint8(); // 1 byte
        const pitchCorrection = this.readInt8(); // 1 byte (符号付き8ビット)
        const sampleLink = this.readUint16();   // 2 bytes
        const sampleType = this.readUint16();   // 2 bytes
        let validOriginalPitch = originalPitch;
      if (originalPitch < 0 || originalPitch > 127) {
        console.warn(`Sample "${name}": Invalid Root Key ${originalPitch}, using 60 (Middle C)`);
        validOriginalPitch = 60;
      }
      console.log(`Sample "${name}": Original Pitch = ${originalPitch}, Valid Pitch = ${validOriginalPitch}`);
      const zure = 60 - originalPitch;
      // ピッチ補正の妥当性チェック
      let validPitchCorrection = pitchCorrection;
      if (pitchCorrection < -99 || pitchCorrection > 99) {
        console.warn(`Sample "${name}": Invalid pitch correction ${pitchCorrection}, using 0`);
        validPitchCorrection = 0;
      }
        // オフセット確認（46バイト進んだはず）
        const bytesRead = this.offset - sampleOffset;
        if (bytesRead !== 46) {
          console.error(`Sample ${i}: Read ${bytesRead} bytes instead of 46!`);
        }

        tempSamples.push({
          name: name.trim(),
          start,
          end,
          startLoop,
          endLoop,
          sampleRate,
          originalPitch,
          pitchCorrection,
          sampleType,
          zure: zure
        });
      }
      
      console.log(`  Read ${tempSamples.length} sample headers`);
      
      // 最後のサンプル（EOS）を除外して検証
      for (let i = 0; i < tempSamples.length - 1; i++) {
        const sample = tempSamples[i];
        
        if (i < 5) {
          console.log(`    Sample ${i}: "${sample.name}"`);
          console.log(`      Range: ${sample.start}-${sample.end} (${sample.end-sample.start} samples)`);
          console.log(`      Loop: ${sample.startLoop}-${sample.endLoop}`);
          console.log(`      Rate: ${sample.sampleRate}Hz, Pitch: ${sample.originalPitch}, Correction: ${sample.pitchCorrection}`);
          console.log(`      Type: ${sample.sampleType}`);
        }

        // 終端サンプル（EOS）をスキップ
        const isEOS = sample.name === 'EOS' || sample.name === '';
        
        // 妥当性チェック
        const isValidRange = sample.end > sample.start && sample.start >= 0;
        const isValidRate = sample.sampleRate >= 3000 && sample.sampleRate <= 192000;
        const isValidPitch = sample.originalPitch >= 0 && sample.originalPitch <= 127;
        const lengthCheck = (sample.end - sample.start) < 100000000;
        
        if (!isEOS && isValidRange && isValidRate && lengthCheck) {
          this.samples.push({
            name: sample.name,
            start: sample.start,
            end: sample.end,
            startLoop: sample.startLoop,
            endLoop: sample.endLoop,
            sampleRate: sample.sampleRate,
            originalPitch: isValidPitch ? sample.originalPitch : 60,
            pitchCorrection: sample.pitchCorrection,
            zure: sample.zure
          });
        } else if (i < 5) {
          const reason = isEOS ? 'EOS' : 
                        !isValidRange ? `invalid range (${sample.start}-${sample.end})` :
                        !isValidRate ? `invalid rate (${sample.sampleRate}Hz)` :
                        !lengthCheck ? 'too long' : 'invalid';
          console.log(`      -> Skipped (${reason})`);
        }
      }
      
      console.log(`  Successfully parsed ${this.samples.length} valid samples out of ${tempSamples.length - 1}`);
    } catch (e) {
      console.error('Error parsing sample headers:', e.message, 'at offset:', this.offset);
      console.error('Stack:', e.stack);
    }
  }
  
  readInt8() {
    this.checkBounds(1);
    const v = this.data.getInt8(this.offset);
    this.offset += 1;
    return v;
  }
}

// ============ SoundFont Synth ============
class SoundFontSynth {
  constructor(audioCtx, soundFont) {
    this.audioCtx = audioCtx;
    this.sf = soundFont;
    this.master = audioCtx.createGain();
    this.master.gain.value = 0.5;
    this.master.connect(audioCtx.destination);
    
    this.channelAnalysers = [];
    this.channelGains = [];
    for (let i = 0; i < 16; i++) {
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const gain = audioCtx.createGain();
      gain.gain.value = 1.0;
      gain.connect(analyser);
      analyser.connect(this.master);
      this.channelAnalysers.push(analyser);
      this.channelGains.push(gain);
    }
    
    this.activeNotes = new Map();
    this.channelPrograms = new Array(16).fill(0);
    
    // AudioBufferキャッシュ
    this.sampleBuffers = new Map();
    
    // プログラム番号ごとのサンプルマッピング
    this.programToSamples = new Map();
    
    this.prepareSamples();
    this.buildProgramMapping();
  }

  prepareSamples() {
    if (!this.sf.sampleData || !this.sf.samples) {
      console.warn('No sample data available');
      return;
    }
    
    console.log('Preparing audio buffers from', this.sf.samples.length, 'samples...');
    console.log('Sample data length:', this.sf.sampleData.length);
    
    let validSamples = 0;
    let invalidSamples = 0;
    
    for (let i = 0; i < this.sf.samples.length; i++) {
      const sample = this.sf.samples[i];
      
      // デバッグ: 最初の5サンプルを詳細表示
      if (i < 5) {
        console.log(`Sample ${i}: "${sample.name}"`);
        console.log(`  Range: ${sample.start} - ${sample.end} (length: ${sample.end - sample.start})`);
        console.log(`  Loop: ${sample.startLoop} - ${sample.endLoop}`);
        console.log(`  Rate: ${sample.sampleRate}Hz, Pitch: ${sample.originalPitch}`);
      }
      
      // サンプルの妥当性チェック
      if (sample.start >= sample.end) {
        if (i < 5) console.log(`  ✗ Invalid range`);
        invalidSamples++;
        continue;
      }
      
      const length = sample.end - sample.start;
      
      if (length <= 0 || length > 100000000) {
        if (i < 5) console.log(`  ✗ Invalid length: ${length}`);
        invalidSamples++;
        continue;
      }
      
      if (sample.end > this.sf.sampleData.length) {
        if (i < 5) console.log(`  ✗ Out of bounds: ${sample.end} > ${this.sf.sampleData.length}`);
        invalidSamples++;
        continue;
      }
      
      let sampleRate = sample.sampleRate;
      if (!sampleRate || sampleRate < 3000 || sampleRate > 768000 || !isFinite(sampleRate)) {
        if (i < 5) console.log(`  ⚠ Invalid rate ${sampleRate}Hz, using 44100Hz`);
        sampleRate = 44100;
      }
      
      try {
        const buffer = this.audioCtx.createBuffer(1, length, sampleRate);
        const channelData = buffer.getChannelData(0);
        
        // サンプルデータをコピー
        let hasNonZero = false;
        for (let j = 0; j < length; j++) {
          const sampleValue = this.sf.sampleData[sample.start + j];
          channelData[j] = sampleValue / 32768.0;
          if (sampleValue !== 0) hasNonZero = true;
        }
        
        // 無音サンプルをチェック
        if (!hasNonZero) {
          if (i < 5) console.log(`  ⚠ Silent sample`);
        }
        
        let loopStart = sample.startLoop - sample.start;
        let loopEnd = sample.endLoop - sample.start;
        
        if (loopStart < 0 || loopStart >= length) loopStart = 0;
        if (loopEnd <= loopStart || loopEnd > length) loopEnd = 0;
        
        this.sampleBuffers.set(i, {
          buffer,
          loopStart,
          loopEnd,
          originalPitch: sample.originalPitch || 60,
          sampleRate,
          name: sample.name,
          zure: sample.zure
        });
        
        validSamples++;
        if (i < 5) console.log(`  ✓ Buffer created successfully`);
      } catch (e) {
        if (i < 5) console.log(`  ✗ Failed:`, e.message);
        invalidSamples++;
      }
    }
    
    console.log(`Sample preparation complete:`);
    console.log(`  Valid: ${validSamples}`);
    console.log(`  Invalid: ${invalidSamples}`);
    console.log(`  Total buffers: ${this.sampleBuffers.size}`);
  }

  buildProgramMapping() {
    console.log('Building program to sample mapping...');
    console.log(`  Presets: ${this.sf.presets.length}`);
    console.log(`  Instruments: ${this.sf.instruments.length}`);
    console.log(`  Samples: ${this.sf.samples.length}`);
    console.log(`  Valid sample buffers: ${this.sampleBuffers.size}`);
    console.log(`  PresetBags: ${this.sf.presetBags.length}`);
    console.log(`  PresetGens: ${this.sf.presetGens.length}`);
    console.log(`  InstrumentBags: ${this.sf.instrumentBags.length}`);
    console.log(`  InstrumentGens: ${this.sf.instrumentGens.length}`);
    
    // プリセットからインストゥルメント、サンプルへのマッピングを構築
    for (let presetIdx = 0; presetIdx < this.sf.presets.length; presetIdx++) {
      const preset = this.sf.presets[presetIdx];
      const program = preset.preset;
      const bank = preset.bank;
      
      // 通常はbank 0を使用
      if (bank !== 0 && bank !== 128) continue;
      
      // ドラムキット（bank 128）は後で処理
      const isDrum = (bank === 128);
      
      if (presetIdx < 10 || program === 0) {
        console.log(`\nPreset ${presetIdx}: "${preset.name}" (bank=${bank}, program=${program})`);
      }
      
      const samplesForProgram = new Array(128);
      
      // プリセットバッグからインストゥルメントを取得
      const bagStart = preset.presetBagNdx;
      const nextPreset = this.sf.presets[presetIdx + 1];
      const bagEnd = nextPreset ? nextPreset.presetBagNdx : this.sf.presetBags.length;
      
      if (presetIdx < 10 || program === 0) {
        console.log(`  Preset bags: ${bagStart} to ${bagEnd}`);
      }
      
      for (let bagIdx = bagStart; bagIdx < bagEnd; bagIdx++) {
        const bag = this.sf.presetBags[bagIdx];
        if (!bag) continue;
        
        const genStart = bag.genNdx;
        const genEnd = this.sf.presetBags[bagIdx + 1]?.genNdx || this.sf.presetGens.length;
        
        let keyRange = { lo: 0, hi: 127 };
        let instrumentIdx = null;
        
        // ジェネレータを解析
        for (let genIdx = genStart; genIdx < genEnd; genIdx++) {
          const gen = this.sf.presetGens[genIdx];
          if (!gen) continue;
          
          if (gen.oper === 41) { // instrument
            instrumentIdx = gen.amount;
          } else if (gen.oper === 43) { // keyRange
            keyRange.lo = gen.amount & 0xFF;
            keyRange.hi = (gen.amount >> 8) & 0xFF;
          }
        }
        
        if (instrumentIdx === null) continue;
        
        if (presetIdx < 10 || program === 0) {
          console.log(`    Bag ${bagIdx}: instrument=${instrumentIdx}, keys=${keyRange.lo}-${keyRange.hi}`);
        }
        
        // インストゥルメントからサンプルを取得
        if (instrumentIdx < this.sf.instruments.length) {
          const inst = this.sf.instruments[instrumentIdx];
          const instBagStart = inst.instBagNdx;
          const nextInst = this.sf.instruments[instrumentIdx + 1];
          const instBagEnd = nextInst ? nextInst.instBagNdx : this.sf.instrumentBags.length;
          
          for (let iBagIdx = instBagStart; iBagIdx < instBagEnd; iBagIdx++) {
            const iBag = this.sf.instrumentBags[iBagIdx];
            if (!iBag) continue;
            
            const iGenStart = iBag.genNdx;
            const iGenEnd = this.sf.instrumentBags[iBagIdx + 1]?.genNdx || this.sf.instrumentGens.length;
            
            let iKeyRange = { lo: 0, hi: 127 };
            let sampleIdx = null;
            
            for (let iGenIdx = iGenStart; iGenIdx < iGenEnd; iGenIdx++) {
              const iGen = this.sf.instrumentGens[iGenIdx];
              if (!iGen) continue;
              
              if (iGen.oper === 53) { // sampleID
                sampleIdx = iGen.amount;
              } else if (iGen.oper === 43) { // keyRange
                iKeyRange.lo = iGen.amount & 0xFF;
                iKeyRange.hi = (iGen.amount >> 8) & 0xFF;
              }
            }
            
            if (sampleIdx === null) continue;
            
            // キーレンジを統合
            const finalLo = Math.max(keyRange.lo, iKeyRange.lo);
            const finalHi = Math.min(keyRange.hi, iKeyRange.hi);
            
            // ★重要: sampleBuffersに実際に存在するかチェック
            if (this.sampleBuffers.has(sampleIdx)) {
              const sampleInfo = this.sampleBuffers.get(sampleIdx);
              if (presetIdx < 10 || program === 0) {
                console.log(`      Sample ${sampleIdx} (${sampleInfo?.name}) -> keys ${finalLo}-${finalHi}`);
              }
              
              for (let note = finalLo; note <= finalHi; note++) {
                samplesForProgram[note] = sampleIdx;
              }
            } else {
              // サンプルが無効な場合はスキップ
              if (presetIdx < 3) {
                console.warn(`      Sample ${sampleIdx} not available (invalid or out of range)`);
              }
            }
          }
        }
      }
      
      // マッピングを保存
      const mappedNotes = samplesForProgram.filter(s => s !== undefined).length;
      if (mappedNotes > 0) {
        this.programToSamples.set(program, samplesForProgram);
        if (presetIdx < 10 || program === 0) {
          console.log(`  -> Mapped ${mappedNotes}/128 notes to samples`);
        }
      } else {
        if (presetIdx < 10 || program === 0) {
          console.warn(`  -> No valid samples mapped for program ${program}`);
        }
      }
    }
    
    console.log(`\nMapping complete: ${this.programToSamples.size} programs successfully mapped`);
    console.log(`Programs with samples:`, Array.from(this.programToSamples.keys()).slice(0, 20));
  }

  findSample(program, note) {
    // サンプルが無い場合
    if (this.sampleBuffers.size === 0) {
      console.warn('No samples available');
      return null;
    }
    
    // プログラム番号のマッピングを使用
    const samplesForProgram = this.programToSamples.get(program);
    
    if (samplesForProgram && samplesForProgram[note] !== undefined) {
      const sampleIdx = samplesForProgram[note];
      const sample = this.sampleBuffers.get(sampleIdx);
      
      // デバッグ: 最初の数回のノートオンをログ
      if (this.debugCount === undefined) this.debugCount = 0;
      if (this.debugCount < 10) {
        console.log(`Program ${program}, Note ${note} -> Sample ${sampleIdx}: ${sample?.name}, pitch=${sample?.originalPitch}`);
        this.debugCount++;
      }
      
      return sample;
    }
    
    // フォールバック: 最も近いピッチのサンプルを探す
    let bestIndex = 0;
    let bestDiff = 999;
    
    this.sampleBuffers.forEach((info, idx) => {
      const diff = Math.abs(info.originalPitch - note);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestIndex = idx;
      }
    });
    
    const fallbackSample = this.sampleBuffers.get(bestIndex);
    
    if (this.debugCount < 10) {
      console.log(`Program ${program}, Note ${note} -> Fallback Sample ${bestIndex}: ${fallbackSample?.name}, pitch=${fallbackSample?.originalPitch}`);
      this.debugCount++;
    }
    
    return fallbackSample;
  }

  noteOn(channel, note, velocity, when,compressor) {
    const program = this.channelPrograms[channel];
    const sampleInfo = this.findSample(program, note);
    
    if (!sampleInfo) return;
    
    const key = `${channel}-${note}`;
    if (this.activeNotes.has(key)) {
      this.noteOff(channel, note, when);
    }
    
    // 時刻が負の値にならないように保証
    const now = this.audioCtx.currentTime;
    const scheduleTime = Math.max(when, now);
    
    const source = this.audioCtx.createBufferSource();
    source.connect(compressor).connect(this.audioCtx.destination);
    source.buffer = sampleInfo.buffer;
    const pitch = sampleInfo.originalPitch + sampleInfo.zure;
    console.log(sampleInfo.zure);
    // ピッチ調整（セント単位で正確に）
    const pitchOffset = note - pitch;
    console.log(pitch);
    const playbackRate = Math.pow(2, pitchOffset / 12);
    source.playbackRate.value = playbackRate;
    
    // ループ設定（有効なループポイントがある場合のみ）
    if (sampleInfo.loopStart > 0 && sampleInfo.loopEnd > sampleInfo.loopStart) {
      source.loop = true;
      const duration = sampleInfo.buffer.duration;
      const sampleRate = sampleInfo.buffer.sampleRate;
      source.loopStart = sampleInfo.loopStart / sampleRate;
      source.loopEnd = sampleInfo.loopEnd / sampleRate;
    }
   
    // ベロシティベースの音量調整
    const gain = this.audioCtx.createGain();
    const vel = Math.pow(velocity / 127, 0.5); // ベロシティカーブを適用
    
    console.log(vel);
    gain.gain.setValueAtTime(0, scheduleTime);
    gain.gain.linearRampToValueAtTime(1.1 * 0.8, scheduleTime + 0.005);
    
    // フィルター追加（高周波ノイズを減らす）
    const filter = this.audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 8000;
    filter.Q.value = 0.5;
    
    source.connect(filter);
    filter.connect(gain);
    gain.connect(this.channelGains[channel]);
    
    source.start(scheduleTime);
    
    this.activeNotes.set(key, { source, gain, startTime: scheduleTime });
  }

  noteOff(channel, note, when) {
    const key = `${channel}-${note}`;
    const info = this.activeNotes.get(key);
    if (!info) return;
    
    const { source, gain } = info;
    
    // 時刻が負の値にならないように保証
    const now = this.audioCtx.currentTime;
    const scheduleTime = Math.max(when, now);
    
    gain.gain.setValueAtTime(gain.gain.value, scheduleTime);
    gain.gain.linearRampToValueAtTime(0, scheduleTime + 0.2);
    source.stop(scheduleTime + 0.25);
    
    this.activeNotes.delete(key);
  }

  programChange(channel, program) {
    if (program < 0 || program > 127) return;
    this.channelPrograms[channel] = program;
    console.log(`Channel ${channel} -> Program ${program}`);
  }
}

// ============ MIDI Parser (元のコードから) ============
function parseMidi(arrayBuffer) {
  const data = new DataView(arrayBuffer);
  let offset = 0;

  function readUint32BE() {
    const v = data.getUint32(offset, false);
    offset += 4;
    return v;
  }
  function readUint16BE() {
    const v = data.getUint16(offset, false);
    offset += 2;
    return v;
  }
  function readBytes(n) {
    const bytes = [];
    for (let i = 0; i < n; i++) bytes.push(data.getUint8(offset++));
    return bytes;
  }
  function readStr(n) {
    return String.fromCharCode(...readBytes(n));
  }
  function readVarLen() {
    let value = 0;
    while (true) {
      const b = data.getUint8(offset++);
      value = (value << 7) | (b & 0x7F);
      if ((b & 0x80) === 0) break;
    }
    return value;
  }

  const headerId = readStr(4);
  if (headerId !== "MThd") throw new Error("Invalid MIDI header");
  const headerLength = readUint32BE();
  const formatType = readUint16BE();
  const trackCount = readUint16BE();
  const division = readUint16BE();
  if (headerLength > 6) offset += (headerLength - 6);

  const tracks = [];
  for (let t = 0; t < trackCount; t++) {
    const trackId = readStr(4);
    if (trackId !== "MTrk") throw new Error("Invalid Track header");
    const trackLength = readUint32BE();
    const trackEnd = offset + trackLength;

    const events = [];
    let runningStatus = null;
    let absTicks = 0;

    while (offset < trackEnd) {
      const delta = readVarLen();
      absTicks += delta;

      let statusByte = data.getUint8(offset++);
      if (statusByte < 0x80) {
        offset--;
        statusByte = runningStatus;
      } else {
        runningStatus = statusByte;
      }

      if (statusByte === 0xFF) {
        const metaType = data.getUint8(offset++);
        const length = readVarLen();
        const metaData = readBytes(length);
        events.push({ absTicks, type: "meta", metaType, data: metaData });
      } else if (statusByte === 0xF0 || statusByte === 0xF7) {
        const length = readVarLen();
        const sysExData = readBytes(length);
        events.push({ absTicks, type: "sysex", data: sysExData });
      } else {
        const evtType = statusByte >> 4;
        const channel = statusByte & 0x0F;
        const needsTwo = !(evtType === 0xC || evtType === 0xD);
        const p1 = data.getUint8(offset++);
        const p2 = needsTwo ? data.getUint8(offset++) : null;
        events.push({ absTicks, type: "midi", evtType, channel, p1, p2 });
      }
    }
    tracks.push(events);
  }

  return { header: { formatType, trackCount, division }, tracks };
}

function buildTempoMap(tracks, division) {
  const tempoEvents = [];
  for (const trk of tracks) {
    for (const ev of trk) {
      if (ev.type === "meta" && ev.metaType === 0x51 && ev.data.length === 3) {
        const mpb = (ev.data[0] << 16) | (ev.data[1] << 8) | ev.data[2];
        tempoEvents.push({ absTicks: ev.absTicks, microsecPerQuarter: mpb });
      }
    }
  }
  tempoEvents.sort((a, b) => a.absTicks - b.absTicks);
  const segments = [];
  let lastTick = 0;
  let currentMicro = 500000;
  let currentSec = 0;

  segments.push({ startTick: 0, startSec: 0, micro: currentMicro });
  for (const t of tempoEvents) {
    const deltaTicks = t.absTicks - lastTick;
    const secDelta = (deltaTicks * currentMicro) / (division * 1_000_000);
    currentSec += secDelta;
    segments.push({ startTick: t.absTicks, startSec: currentSec, micro: t.microsecPerQuarter });
    lastTick = t.absTicks;
    currentMicro = t.microsecPerQuarter;
  }
  return segments;
}

function ticksToSeconds(absTicks, segments, division) {
  let seg = segments[0];
  for (let i = 1; i < segments.length; i++) {
    if (segments[i].startTick <= absTicks) seg = segments[i];
    else break;
  }
  const deltaTicks = absTicks - seg.startTick;
  const secDelta = (deltaTicks * seg.micro) / (division * 1_000_000);
  return seg.startSec + secDelta;
}

function collectAllEvents(tracks) {
  const all = [];
  for (const trk of tracks) for (const ev of trk) all.push(ev);
  all.sort((a, b) => a.absTicks - b.absTicks);
  return all;
}

// ============ Visualizer ============
function initVisualizer() {
  const container = document.getElementById('visualizer');
  container.innerHTML = '';
  
  for (let i = 0; i < 16; i++) {
    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'background:#000; padding:0px;';
    
    const label = document.createElement('div');
    label.textContent = `Ch ${i}`;
    label.style.cssText = 'font-size:11px; color:#aaa; margin-bottom:0px;';
    
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 60;
    canvas.id = `canvas${i}`;
    canvas.style.cssText = 'width:100%; height:60px; display:block;';
    
    wrapper.appendChild(label);
    wrapper.appendChild(canvas);
    container.appendChild(wrapper);
  }
}

let animationId = null;
function animate(synth) {
  if (!synth) return;
  
  for (let i = 0; i < 16; i++) {
    const canvas = document.getElementById(`canvas${i}`);
    if (!canvas) continue;
    
    const ctx = canvas.getContext('2d');
    const analyser = synth.channelAnalysers[i];
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    analyser.getByteTimeDomainData(dataArray);
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.lineWidth = 1.0;
    ctx.strokeStyle = `hsl(${i * 22.5}, 100%, 60%)`;
    ctx.beginPath();
    
    const sliceWidth = canvas.width / bufferLength;
    let x = 0;
    
    for (let j = 0; j < bufferLength; j++) {
      const v = dataArray[j] / 128.0;
      const y = v * canvas.height / 2;
      
      if (j === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();
  }
  
  animationId = requestAnimationFrame(() => animate(synth));
}

// ============ UI ============
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const sf2Input = document.getElementById('sf2File');
const midiInput = document.getElementById('midiFile');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const logEl = document.getElementById('log');
const sf2Status = document.getElementById('sf2Status');

let soundFont = null;
let parsed = null;
let synth = null;
let stopCallback = null;

function log(msg) {
  logEl.textContent += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

sf2Input.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  sf2Status.textContent = 'Loading...';
  log(`Loading SoundFont: ${file.name}`);
  
  try {
    const buf = await file.arrayBuffer();
    const parser = new SoundFontParser(buf);
    soundFont = parser.parse();
    
    sf2Status.textContent = `✓ Loaded (${soundFont.samples.length} samples)`;
    sf2Status.style.color = '#4a4';
    log(`SoundFont loaded: ${soundFont.presets.length} presets, ${soundFont.samples.length} samples`);
    
    if (parsed) playBtn.disabled = false;
  } catch (err) {
    sf2Status.textContent = '✗ Error';
    sf2Status.style.color = '#a44';
    log(`Error loading SoundFont: ${err.message}`);
  }
});

midiInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const buf = await file.arrayBuffer();
    parsed = parseMidi(buf);
    log(`Loaded MIDI: ${file.name}`);
    log(`Format: ${parsed.header.formatType}, Tracks: ${parsed.header.trackCount}, Division: ${parsed.header.division}`);
    
    if (soundFont) playBtn.disabled = false;
  } catch (err) {
    log(`Error loading MIDI: ${err.message}`);
  }
});

playBtn.addEventListener('click', () => {
  if (!parsed || !soundFont) return;
  
  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }
  
  initVisualizer();
  synth = new SoundFontSynth(audioCtx, soundFont);
  const compressor = audioCtx.createDynamicsCompressor();

compressor.threshold.value = -4;
compressor.knee.value = 3;
compressor.ratio.value = 1;
compressor.attack.value = 0.003;
compressor.release.value = 0.25;


  const { division } = parsed.header;
  const tempoMap = buildTempoMap(parsed.tracks, division);
  const all = collectAllEvents(parsed.tracks);
  
  const startTicks = performance.now();
  let idx = 0;
  let isPlaying = true;
  
  stopCallback = () => {
    isPlaying = false;
  };
  
  function step() {
    if (!isPlaying) return;
    
    const lookAhead = 0.15; // ルックアヘッドを150msに延長
    const now = performance.now();
    const audioNow = audioCtx.currentTime;
    
    while (idx < all.length && isPlaying) {
      const ev = all[idx];
      const evTimeMs = ticksToSeconds(ev.absTicks, tempoMap, division) * 1000;
      const deltaMs = evTimeMs - (now - startTicks);
      
      if (deltaMs <= lookAhead * 1000) {
        // スケジュール時刻を計算（最小でも現在時刻+10msを保証）
        const scheduleTime = Math.max(audioNow + deltaMs / 1000, audioNow + 0.01);
        
        if (ev.type === "midi") {
          const ch = ev.channel;
          switch (ev.evtType) {
            case 0x9: {
              const note = ev.p1;
              const vel = ev.p2 || 0;
              if (vel > 0) {
                synth.noteOn(ch, note, vel, scheduleTime,compressor);
              } else {
                synth.noteOff(ch, note, scheduleTime);
              }
              break;
            }
            case 0x8: {
              synth.noteOff(ch, ev.p1, scheduleTime);
              break;
            }
            case 0xC: {
              synth.programChange(ch, ev.p1);
              break;
            }
          }
        }
        idx++;
      } else {
        break;
      }
    }
    
    if (idx < all.length && isPlaying) {
      setTimeout(step, 10);
    } else if (isPlaying) {
      log("Finished.");
      playBtn.disabled = false;
      stopBtn.disabled = true;
    }
  }
  
  playBtn.disabled = true;
  stopBtn.disabled = false;
  log("Playing with SoundFont...");
  animate(synth);
  step();
});

stopBtn.addEventListener('click', () => {
  if (stopCallback) stopCallback();
  
  if (synth) {
    const now = audioCtx.currentTime;
    for (const key of synth.activeNotes.keys()) {
      const [ch, note] = key.split('-').map(Number);
      synth.noteOff(ch, note, now);
    }
  }
  
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
  
  playBtn.disabled = false;
  stopBtn.disabled = true;
  log("Stopped.");
});
</script>
</body>
</html>