<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>MIDI Player with SoundFont (.sf2)</title>
<style>
  body { font-family: system-ui, sans-serif; padding: 20px; background:black; color:white;}
  .log { white-space: pre-wrap; font-family: ui-monospace, monospace; background: #111; color: #ddd; padding: 10px; border-radius: 6px; max-height: 200px; overflow-y: auto; }
  button { margin-right: 8px; padding: 8px 16px; }
  .file-input { margin: 10px 0; }
  .status { color: #4a4; margin: 10px 0; }
</style>
</head>
<body>
  <h1>MIDI Player with SoundFont (.sf2)</h1>
  
  <div class="file-input">
    <label>SoundFont (.sf2): </label>
    <input type="file" id="sf2File" accept=".sf2" />
    <span id="sf2Status" class="status"></span>
  </div>
  
  <div class="file-input">
    <label>MIDI File (.mid): </label>
    <input type="file" id="midiFile" accept=".mid,.midi" />
  </div>
  
  <button id="playBtn" disabled>Play</button>
  <button id="stopBtn" disabled>Stop</button>
  
  <div id="visualizer" style="display:grid; grid-template-columns:repeat(4,1fr); gap:0px; margin:20px 0;">
  </div>
  
  <div class="log" id="log"></div>

<script>
// ============ SoundFont Parser ============
class SoundFontParser {
  constructor(arrayBuffer) {
    this.data = new DataView(arrayBuffer);
    this.offset = 0;
    this.presets = [];
    this.instruments = [];
    this.samples = [];
    this.sampleData = null;
  }

  checkBounds(bytes) {
    if (this.offset + bytes > this.data.byteLength) {
      throw new Error(`Read beyond file bounds: offset=${this.offset}, need=${bytes}, size=${this.data.byteLength}`);
    }
  }

  readString(len) {
    this.checkBounds(len);
    let str = '';
    for (let i = 0; i < len; i++) {
      const c = this.data.getUint8(this.offset++);
      if (c !== 0) str += String.fromCharCode(c);
    }
    return str;
  }

  readUint32() {
    this.checkBounds(4);
    const v = this.data.getUint32(this.offset, true);
    this.offset += 4;
    return v;
  }

  readUint16() {
    this.checkBounds(2);
    const v = this.data.getUint16(this.offset, true);
    this.offset += 2;
    return v;
  }

  readInt16() {
    this.checkBounds(2);
    const v = this.data.getInt16(this.offset, true);
    this.offset += 2;
    return v;
  }

  readUint8() {
    this.checkBounds(1);
    return this.data.getUint8(this.offset++);
  }

  findChunk(id, startOffset = 0) {
    this.offset = startOffset;
    while (this.offset < this.data.byteLength - 8) {
      const chunkId = this.readString(4);
      const size = this.readUint32();
      if (chunkId === id) {
        return { offset: this.offset, size };
      }
      this.offset += size;
    }
    return null;
  }

  findSubChunk(parentOffset, parentSize, id) {
    const endOffset = parentOffset + parentSize;
    this.offset = parentOffset;
    
    while (this.offset < endOffset - 8 && this.offset + 8 <= this.data.byteLength) {
      try {
        const chunkId = this.readString(4);
        const size = this.readUint32();
        if (chunkId === id) {
          return { offset: this.offset, size };
        }
        this.offset += size;
      } catch (e) {
        console.warn('Error reading sub-chunk:', e.message);
        break;
      }
    }
    return null;
  }

  parse() {
    try {
      // RIFFヘッダー確認
      const riff = this.readString(4);
      if (riff !== 'RIFF') throw new Error('Not a valid RIFF file');
      
      const fileSize = this.readUint32();
      const sfbk = this.readString(4);
      if (sfbk !== 'sfbk') throw new Error('Not a SoundFont file');

      console.log('SF2 file detected, size:', fileSize);

      // LISTチャンクを探す
      this.offset = 12; // RIFF header後
      
      while (this.offset < this.data.byteLength - 8 && this.offset + 8 <= this.data.byteLength) {
        try {
          const chunkId = this.readString(4);
          const chunkSize = this.readUint32();
          const chunkDataStart = this.offset;
          
          console.log(`Found chunk: ${chunkId}, size: ${chunkSize}, offset: ${chunkDataStart}`);
          
          // チャンクサイズの妥当性チェック
          if (chunkSize > this.data.byteLength - chunkDataStart + 8) {
            console.warn(`Invalid chunk size: ${chunkSize}, skipping`);
            break;
          }
          
          if (chunkId === 'LIST' && chunkSize >= 4) {
            const listType = this.readString(4);
            console.log(`  LIST type: ${listType}`);
            
            if (listType === 'sdta') {
              // サンプルデータ
              const smplChunk = this.findSubChunk(this.offset, chunkSize - 4, 'smpl');
              if (smplChunk && smplChunk.offset + smplChunk.size <= this.data.byteLength) {
                this.offset = smplChunk.offset;
                const start = this.offset;
                const sampleCount = Math.floor(smplChunk.size / 2);
                this.sampleData = new Int16Array(this.data.buffer, start, sampleCount);
                console.log('Sample data loaded:', smplChunk.size, 'bytes,', sampleCount, 'samples');
              }
            } else if (listType === 'pdta') {
              // プリセット/インストゥルメントデータ
              console.log('Processing pdta chunk...');
              this.parsePdta(this.offset, chunkSize - 4);
            }
          }
          
          this.offset = chunkDataStart + chunkSize;
          
          // アライメント調整（ワード境界）
          if (chunkSize % 2 === 1) {
            this.offset++;
          }
        } catch (e) {
          console.warn('Error processing chunk:', e.message);
          break;
        }
      }

      if (this.presets.length === 0) {
        console.warn('No presets found');
      }
      
      if (this.samples.length === 0) {
        console.warn('No samples found');
      }

      return {
        presets: this.presets,
        instruments: this.instruments,
        samples: this.samples,
        sampleData: this.sampleData
      };
    } catch (e) {
      console.error('Parse error:', e.message, 'at offset:', this.offset);
      throw e;
    }
  }

  parsePdta(startOffset, size) {
    const endOffset = Math.min(startOffset + size, this.data.byteLength);
    this.offset = startOffset;
    
    while (this.offset < endOffset - 8 && this.offset + 8 <= this.data.byteLength) {
      try {
        const subId = this.readString(4);
        const subSize = this.readUint32();
        const subStart = this.offset;
        
        console.log(`  pdta sub-chunk: ${subId}, size: ${subSize}, offset: ${subStart}`);
        
        // サブチャンクサイズの妥当性チェック
        if (subSize > this.data.byteLength - subStart + 8 || subSize < 0) {
          console.warn(`Invalid sub-chunk size: ${subSize}, skipping rest of pdta`);
          break;
        }

        if (subId === 'phdr' && subSize >= 38) {
          this.parsePresetHeaders(subSize);
        } else if (subId === 'pbag') {
          // Preset bags (スキップ)
        } else if (subId === 'pmod') {
          // Preset modulators (スキップ)
        } else if (subId === 'pgen') {
          // Preset generators (スキップ)
        } else if (subId === 'inst' && subSize >= 22) {
          this.parseInstruments(subSize);
        } else if (subId === 'ibag') {
          // Instrument bags (スキップ)
        } else if (subId === 'imod') {
          // Instrument modulators (スキップ)
        } else if (subId === 'igen') {
          // Instrument generators (スキップ)
        } else if (subId === 'shdr' && subSize >= 46) {
          this.parseSampleHeaders(subSize);
        }

        this.offset = subStart + subSize;
        
        // アライメント調整
        if (subSize % 2 === 1) {
          this.offset++;
        }
      } catch (e) {
        console.warn('Error parsing pdta sub-chunk:', e.message);
        break;
      }
    }
  }

  parsePresetHeaders(size) {
    const count = Math.floor(size / 38);
    console.log(`  Parsing ${count} preset headers`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 38 > this.data.byteLength) {
          console.warn('Reached end of file while parsing presets');
          break;
        }
        
        const name = this.readString(20);
        const preset = this.readUint16();
        const bank = this.readUint16();
        const presetBagNdx = this.readUint16();
        const library = this.readUint32();
        const genre = this.readUint32();
        const morphology = this.readUint32();
        
        // 終端プリセットをスキップ
        if (i < count - 1) {
          this.presets.push({ name, preset, bank, presetBagNdx });
          if (i < 5) console.log(`    Preset: ${name} (${bank}:${preset})`);
        }
      }
    } catch (e) {
      console.warn('Error parsing preset headers:', e.message);
    }
  }

  parseInstruments(size) {
    const count = Math.floor(size / 22);
    console.log(`  Parsing ${count} instruments`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 22 > this.data.byteLength) {
          console.warn('Reached end of file while parsing instruments');
          break;
        }
        
        const name = this.readString(20);
        const instBagNdx = this.readUint16();
        
        // 終端インストゥルメントをスキップ
        if (i < count - 1) {
          this.instruments.push({ name, instBagNdx });
          if (i < 5) console.log(`    Instrument: ${name}`);
        }
      }
    } catch (e) {
      console.warn('Error parsing instruments:', e.message);
    }
  }

  parseSampleHeaders(size) {
    const count = Math.floor(size / 46);
    console.log(`  Parsing ${count} sample headers`);
    
    try {
      for (let i = 0; i < count; i++) {
        if (this.offset + 46 > this.data.byteLength) {
          console.warn(`Reached end of file while parsing samples (${i}/${count})`);
          break;
        }
        
        const startOffset = this.offset;
        
        const name = this.readString(20);
        const start = this.readUint32();
        const end = this.readUint32();
        const startLoop = this.readUint32();
        const endLoop = this.readUint32();
        const sampleRate = this.readUint32();
        const originalPitch = this.readUint8();
        const pitchCorrection = this.readInt16();
        const sampleLink = this.readUint16();
        const sampleType = this.readUint16();

        // デバッグ: 最初の数サンプルの詳細を表示
        if (i < 3) {
          console.log(`    Sample ${i}: ${name}`);
          console.log(`      Range: ${start}-${end} (${end-start} samples)`);
          console.log(`      Loop: ${startLoop}-${endLoop}`);
          console.log(`      Rate: ${sampleRate}Hz, Pitch: ${originalPitch}`);
        }

        // 終端サンプル（EOS）をスキップ
        const isEOS = name.trim() === 'EOS' || name.trim() === '';
        
        // 有効なサンプルのみ追加
        if (i < count - 1 && !isEOS && end > start && sampleRate > 0 && sampleRate < 200000) {
          this.samples.push({
            name: name.trim(),
            start,
            end,
            startLoop,
            endLoop,
            sampleRate,
            originalPitch: originalPitch > 0 && originalPitch < 128 ? originalPitch : 60,
            pitchCorrection
          });
        } else if (i < 3) {
          console.log(`      -> Skipped (${isEOS ? 'EOS' : 'invalid'})`);
        }
      }
      
      console.log(`  Successfully parsed ${this.samples.length} valid samples`);
    } catch (e) {
      console.warn('Error parsing sample headers:', e.message, 'at offset:', this.offset);
    }
  }
}

// ============ SoundFont Synth ============
class SoundFontSynth {
  constructor(audioCtx, soundFont) {
    this.audioCtx = audioCtx;
    this.sf = soundFont;
    this.master = audioCtx.createGain();
    this.master.gain.value = 0.5;
    this.master.connect(audioCtx.destination);
    
    this.channelAnalysers = [];
    this.channelGains = [];
    for (let i = 0; i < 16; i++) {
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const gain = audioCtx.createGain();
      gain.gain.value = 1.0;
      gain.connect(analyser);
      analyser.connect(this.master);
      this.channelAnalysers.push(analyser);
      this.channelGains.push(gain);
    }
    
    this.activeNotes = new Map();
    this.channelPrograms = new Array(16).fill(0);
    
    // AudioBufferキャッシュ
    this.sampleBuffers = new Map();
    this.prepareSamples();
  }

  prepareSamples() {
    if (!this.sf.sampleData || !this.sf.samples) {
      console.warn('No sample data available');
      return;
    }
    
    console.log('Preparing audio buffers from', this.sf.samples.length, 'samples...');
    
    for (let i = 0; i < this.sf.samples.length; i++) {
      const sample = this.sf.samples[i];
      
      // サンプルの妥当性チェック
      if (sample.start >= sample.end) {
        console.warn(`Sample ${i} (${sample.name}): invalid range ${sample.start}-${sample.end}`);
        continue;
      }
      
      const length = sample.end - sample.start;
      
      // サンプル長の妥当性チェック
      if (length <= 0 || length > 100000000) {
        console.warn(`Sample ${i} (${sample.name}): invalid length ${length}`);
        continue;
      }
      
      // サンプルデータの範囲チェック
      if (sample.end > this.sf.sampleData.length) {
        console.warn(`Sample ${i} (${sample.name}): end position ${sample.end} exceeds sample data length ${this.sf.sampleData.length}`);
        continue;
      }
      
      // サンプルレートの妥当性チェック（Web Audio APIの範囲: 3000-768000 Hz）
      let sampleRate = sample.sampleRate;
      if (!sampleRate || sampleRate < 3000 || sampleRate > 768000 || !isFinite(sampleRate)) {
        console.warn(`Sample ${i} (${sample.name}): invalid sample rate ${sampleRate}Hz, using 44100Hz`);
        sampleRate = 44100;
      }
      
      try {
        // バッファ作成（検証済みのsampleRateを使用）
        const buffer = this.audioCtx.createBuffer(1, length, sampleRate);
        const channelData = buffer.getChannelData(0);
        
        for (let j = 0; j < length; j++) {
          const sampleValue = this.sf.sampleData[sample.start + j];
          channelData[j] = sampleValue / 32768.0;
        }
        
        // ループポイントの妥当性チェック
        let loopStart = sample.startLoop - sample.start;
        let loopEnd = sample.endLoop - sample.start;
        
        if (loopStart < 0 || loopStart >= length) loopStart = 0;
        if (loopEnd <= loopStart || loopEnd > length) loopEnd = 0;
        
        this.sampleBuffers.set(i, {
          buffer,
          loopStart,
          loopEnd,
          originalPitch: sample.originalPitch || 60,
          sampleRate
        });
        
        if (i < 3) {
          console.log(`  ✓ Sample ${i} (${sample.name}): ${length} samples, ${sampleRate}Hz, pitch=${sample.originalPitch}`);
        }
      } catch (e) {
        console.warn(`✗ Failed to create buffer for sample ${i} (${sample.name}):`, e.message);
      }
    }
    
    console.log(`Successfully prepared ${this.sampleBuffers.size} audio buffers`);
  }

  findSample(program, note) {
    // 簡易的な実装: プログラム番号とノート番号に基づいてサンプルを選択
    
    // サンプルが無い場合
    if (this.sampleBuffers.size === 0) {
      console.warn('No samples available');
      return null;
    }
    
    // プログラム番号をサンプル数の範囲にマッピング
    const sampleCount = this.sampleBuffers.size;
    let sampleIndex = Math.min(program % sampleCount, sampleCount - 1);
    
    // 最も近いサンプルを探す（ピッチベース）
    let bestIndex = sampleIndex;
    let bestDiff = 999;
    
    for (let i = 0; i < sampleCount; i++) {
      const info = this.sampleBuffers.get(i);
      if (!info) continue;
      
      const diff = Math.abs(info.originalPitch - note);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestIndex = i;
      }
    }
    
    // ピッチ差が大きすぎる場合はプログラム番号ベースに戻す
    if (bestDiff > 36) {
      bestIndex = sampleIndex;
    }
    
    return this.sampleBuffers.get(bestIndex);
  }

  noteOn(channel, note, velocity, when) {
    const program = this.channelPrograms[channel];
    const sampleInfo = this.findSample(program, note);
    
    if (!sampleInfo) return;
    
    const key = `${channel}-${note}`;
    if (this.activeNotes.has(key)) {
      this.noteOff(channel, note, when);
    }
    
    const source = this.audioCtx.createBufferSource();
    source.buffer = sampleInfo.buffer;
    
    // ピッチ調整
    const pitchOffset = note - sampleInfo.originalPitch;
    source.playbackRate.value = Math.pow(2, pitchOffset / 12);
    
    // ループ設定
    if (sampleInfo.loopStart > 0 && sampleInfo.loopEnd > sampleInfo.loopStart) {
      source.loop = true;
      source.loopStart = sampleInfo.loopStart / sampleInfo.buffer.sampleRate;
      source.loopEnd = sampleInfo.loopEnd / sampleInfo.buffer.sampleRate;
    }
    
    const gain = this.audioCtx.createGain();
    const vel = velocity / 127;
    gain.gain.setValueAtTime(0, when);
    gain.gain.linearRampToValueAtTime(vel, when + 0.01);
    
    source.connect(gain);
    gain.connect(this.channelGains[channel]);
    
    source.start(when);
    
    this.activeNotes.set(key, { source, gain, startTime: when });
  }

  noteOff(channel, note, when) {
    const key = `${channel}-${note}`;
    const info = this.activeNotes.get(key);
    if (!info) return;
    
    const { source, gain } = info;
    
    gain.gain.setValueAtTime(gain.gain.value, when);
    gain.gain.linearRampToValueAtTime(0, when + 0.2);
    source.stop(when + 0.25);
    
    this.activeNotes.delete(key);
  }

  programChange(channel, program) {
    this.channelPrograms[channel] = program;
  }
}

// ============ MIDI Parser (元のコードから) ============
function parseMidi(arrayBuffer) {
  const data = new DataView(arrayBuffer);
  let offset = 0;

  function readUint32BE() {
    const v = data.getUint32(offset, false);
    offset += 4;
    return v;
  }
  function readUint16BE() {
    const v = data.getUint16(offset, false);
    offset += 2;
    return v;
  }
  function readBytes(n) {
    const bytes = [];
    for (let i = 0; i < n; i++) bytes.push(data.getUint8(offset++));
    return bytes;
  }
  function readStr(n) {
    return String.fromCharCode(...readBytes(n));
  }
  function readVarLen() {
    let value = 0;
    while (true) {
      const b = data.getUint8(offset++);
      value = (value << 7) | (b & 0x7F);
      if ((b & 0x80) === 0) break;
    }
    return value;
  }

  const headerId = readStr(4);
  if (headerId !== "MThd") throw new Error("Invalid MIDI header");
  const headerLength = readUint32BE();
  const formatType = readUint16BE();
  const trackCount = readUint16BE();
  const division = readUint16BE();
  if (headerLength > 6) offset += (headerLength - 6);

  const tracks = [];
  for (let t = 0; t < trackCount; t++) {
    const trackId = readStr(4);
    if (trackId !== "MTrk") throw new Error("Invalid Track header");
    const trackLength = readUint32BE();
    const trackEnd = offset + trackLength;

    const events = [];
    let runningStatus = null;
    let absTicks = 0;

    while (offset < trackEnd) {
      const delta = readVarLen();
      absTicks += delta;

      let statusByte = data.getUint8(offset++);
      if (statusByte < 0x80) {
        offset--;
        statusByte = runningStatus;
      } else {
        runningStatus = statusByte;
      }

      if (statusByte === 0xFF) {
        const metaType = data.getUint8(offset++);
        const length = readVarLen();
        const metaData = readBytes(length);
        events.push({ absTicks, type: "meta", metaType, data: metaData });
      } else if (statusByte === 0xF0 || statusByte === 0xF7) {
        const length = readVarLen();
        const sysExData = readBytes(length);
        events.push({ absTicks, type: "sysex", data: sysExData });
      } else {
        const evtType = statusByte >> 4;
        const channel = statusByte & 0x0F;
        const needsTwo = !(evtType === 0xC || evtType === 0xD);
        const p1 = data.getUint8(offset++);
        const p2 = needsTwo ? data.getUint8(offset++) : null;
        events.push({ absTicks, type: "midi", evtType, channel, p1, p2 });
      }
    }
    tracks.push(events);
  }

  return { header: { formatType, trackCount, division }, tracks };
}

function buildTempoMap(tracks, division) {
  const tempoEvents = [];
  for (const trk of tracks) {
    for (const ev of trk) {
      if (ev.type === "meta" && ev.metaType === 0x51 && ev.data.length === 3) {
        const mpb = (ev.data[0] << 16) | (ev.data[1] << 8) | ev.data[2];
        tempoEvents.push({ absTicks: ev.absTicks, microsecPerQuarter: mpb });
      }
    }
  }
  tempoEvents.sort((a, b) => a.absTicks - b.absTicks);
  const segments = [];
  let lastTick = 0;
  let currentMicro = 500000;
  let currentSec = 0;

  segments.push({ startTick: 0, startSec: 0, micro: currentMicro });
  for (const t of tempoEvents) {
    const deltaTicks = t.absTicks - lastTick;
    const secDelta = (deltaTicks * currentMicro) / (division * 1_000_000);
    currentSec += secDelta;
    segments.push({ startTick: t.absTicks, startSec: currentSec, micro: t.microsecPerQuarter });
    lastTick = t.absTicks;
    currentMicro = t.microsecPerQuarter;
  }
  return segments;
}

function ticksToSeconds(absTicks, segments, division) {
  let seg = segments[0];
  for (let i = 1; i < segments.length; i++) {
    if (segments[i].startTick <= absTicks) seg = segments[i];
    else break;
  }
  const deltaTicks = absTicks - seg.startTick;
  const secDelta = (deltaTicks * seg.micro) / (division * 1_000_000);
  return seg.startSec + secDelta;
}

function collectAllEvents(tracks) {
  const all = [];
  for (const trk of tracks) for (const ev of trk) all.push(ev);
  all.sort((a, b) => a.absTicks - b.absTicks);
  return all;
}

// ============ Visualizer ============
function initVisualizer() {
  const container = document.getElementById('visualizer');
  container.innerHTML = '';
  
  for (let i = 0; i < 16; i++) {
    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'background:#000; padding:0px;';
    
    const label = document.createElement('div');
    label.textContent = `Ch ${i}`;
    label.style.cssText = 'font-size:11px; color:#aaa; margin-bottom:0px;';
    
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 60;
    canvas.id = `canvas${i}`;
    canvas.style.cssText = 'width:100%; height:60px; display:block;';
    
    wrapper.appendChild(label);
    wrapper.appendChild(canvas);
    container.appendChild(wrapper);
  }
}

let animationId = null;
function animate(synth) {
  if (!synth) return;
  
  for (let i = 0; i < 16; i++) {
    const canvas = document.getElementById(`canvas${i}`);
    if (!canvas) continue;
    
    const ctx = canvas.getContext('2d');
    const analyser = synth.channelAnalysers[i];
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    analyser.getByteTimeDomainData(dataArray);
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.lineWidth = 1.0;
    ctx.strokeStyle = `hsl(${i * 22.5}, 100%, 60%)`;
    ctx.beginPath();
    
    const sliceWidth = canvas.width / bufferLength;
    let x = 0;
    
    for (let j = 0; j < bufferLength; j++) {
      const v = dataArray[j] / 128.0;
      const y = v * canvas.height / 2;
      
      if (j === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();
  }
  
  animationId = requestAnimationFrame(() => animate(synth));
}

// ============ UI ============
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const sf2Input = document.getElementById('sf2File');
const midiInput = document.getElementById('midiFile');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const logEl = document.getElementById('log');
const sf2Status = document.getElementById('sf2Status');

let soundFont = null;
let parsed = null;
let synth = null;
let stopCallback = null;

function log(msg) {
  logEl.textContent += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

sf2Input.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  sf2Status.textContent = 'Loading...';
  log(`Loading SoundFont: ${file.name}`);
  
  try {
    const buf = await file.arrayBuffer();
    const parser = new SoundFontParser(buf);
    soundFont = parser.parse();
    
    sf2Status.textContent = `✓ Loaded (${soundFont.samples.length} samples)`;
    sf2Status.style.color = '#4a4';
    log(`SoundFont loaded: ${soundFont.presets.length} presets, ${soundFont.samples.length} samples`);
    
    if (parsed) playBtn.disabled = false;
  } catch (err) {
    sf2Status.textContent = '✗ Error';
    sf2Status.style.color = '#a44';
    log(`Error loading SoundFont: ${err.message}`);
  }
});

midiInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const buf = await file.arrayBuffer();
    parsed = parseMidi(buf);
    log(`Loaded MIDI: ${file.name}`);
    log(`Format: ${parsed.header.formatType}, Tracks: ${parsed.header.trackCount}, Division: ${parsed.header.division}`);
    
    if (soundFont) playBtn.disabled = false;
  } catch (err) {
    log(`Error loading MIDI: ${err.message}`);
  }
});

playBtn.addEventListener('click', () => {
  if (!parsed || !soundFont) return;
  
  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }
  
  initVisualizer();
  synth = new SoundFontSynth(audioCtx, soundFont);
  
  const { division } = parsed.header;
  const tempoMap = buildTempoMap(parsed.tracks, division);
  const all = collectAllEvents(parsed.tracks);
  
  const startTicks = performance.now();
  let idx = 0;
  let isPlaying = true;
  
  stopCallback = () => {
    isPlaying = false;
  };
  
  function step() {
    if (!isPlaying) return;
    
    const lookAhead = 0.1;
    const now = performance.now();
    const audioNow = audioCtx.currentTime;
    
    while (idx < all.length && isPlaying) {
      const ev = all[idx];
      const evTimeMs = ticksToSeconds(ev.absTicks, tempoMap, division) * 1000;
      const deltaMs = evTimeMs - (now - startTicks);
      
      if (deltaMs <= lookAhead * 1000) {
        const scheduleTime = audioNow + deltaMs / 1000;
        
        if (ev.type === "midi") {
          const ch = ev.channel;
          switch (ev.evtType) {
            case 0x9: {
              const note = ev.p1;
              const vel = ev.p2 || 0;
              if (vel > 0) {
                synth.noteOn(ch, note, vel, scheduleTime);
              } else {
                synth.noteOff(ch, note, scheduleTime);
              }
              break;
            }
            case 0x8: {
              synth.noteOff(ch, ev.p1, scheduleTime);
              break;
            }
            case 0xC: {
              synth.programChange(ch, ev.p1);
              break;
            }
          }
        }
        idx++;
      } else {
        break;
      }
    }
    
    if (idx < all.length && isPlaying) {
      setTimeout(step, 10);
    } else if (isPlaying) {
      log("Finished.");
      playBtn.disabled = false;
      stopBtn.disabled = true;
    }
  }
  
  playBtn.disabled = true;
  stopBtn.disabled = false;
  log("Playing with SoundFont...");
  animate(synth);
  step();
});

stopBtn.addEventListener('click', () => {
  if (stopCallback) stopCallback();
  
  if (synth) {
    const now = audioCtx.currentTime;
    for (const key of synth.activeNotes.keys()) {
      const [ch, note] = key.split('-').map(Number);
      synth.noteOff(ch, note, now);
    }
  }
  
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
  
  playBtn.disabled = false;
  stopBtn.disabled = true;
  log("Stopped.");
});
</script>
</body>
</html>
